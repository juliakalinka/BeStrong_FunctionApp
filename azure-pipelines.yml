trigger:
  branches:
    include:
    - main
    - develop
  paths:
    include:
    - 'function_app.py'
    - 'host.json'
    - 'requirements.txt'
    - 'azure-pipelines.yml'

pool:
  vmImage: 'ubuntu-latest'

variables:
  pythonVersion: '3.9'
  functionAppNameProd: 'prodbestrongfuncapp1'
  functionAppNameDev: 'devbestrongfuncapp1'
  resourceGroupProd: 'rg-prod'
  resourceGroupDev: 'rg-dev'

stages:
- stage: Build
  displayName: 'Build and Test'
  jobs:
  - job: Build
    displayName: 'Build Function App'
    steps:
    - task: UsePythonVersion@0
      inputs:
        versionSpec: '$(pythonVersion)'
      displayName: 'Use Python $(pythonVersion)'

    - script: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        
        # Install test dependencies
        pip install pytest pytest-cov flake8
      displayName: 'Install dependencies'

    - script: |
        # Run linting
        echo "Running code quality checks..."
        python -m flake8 function_app.py --max-line-length=120 --ignore=E501,W503 || echo "Linting completed with warnings"
      displayName: 'Code Quality Check'
      continueOnError: true

    - script: |
        echo "Preparing function package..."
        
        # Create a clean directory structure
        mkdir -p $(Build.ArtifactStagingDirectory)/function_package
        
        # Copy function files
        cp function_app.py $(Build.ArtifactStagingDirectory)/function_package/
        cp host.json $(Build.ArtifactStagingDirectory)/function_package/
        cp requirements.txt $(Build.ArtifactStagingDirectory)/function_package/
        
        # Create .funcignore if it doesn't exist
        echo "*.pyc
        __pycache__/
        .git/
        .vscode/
        .pytest_cache/
        tests/
        .coverage
        *.log" > $(Build.ArtifactStagingDirectory)/function_package/.funcignore
        
        # Create local.settings.json template (will be ignored in production)
        echo '{
          "IsEncrypted": false,
          "Values": {
            "AzureWebJobsStorage": "",
            "FUNCTIONS_WORKER_RUNTIME": "python"
          }
        }' > $(Build.ArtifactStagingDirectory)/function_package/local.settings.json
        
        # Create build metadata
        echo "{
          \"build_id\": \"$(Build.BuildId)\",
          \"build_number\": \"$(Build.BuildNumber)\",
          \"source_branch\": \"$(Build.SourceBranch)\",
          \"source_version\": \"$(Build.SourceVersion)\",
          \"build_date\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\",
          \"agent_name\": \"$(Agent.Name)\"
        }" > $(Build.ArtifactStagingDirectory)/function_package/build_info.json
        
        echo "Package contents:"
        ls -la $(Build.ArtifactStagingDirectory)/function_package/
      displayName: 'Prepare Function Package'

    - task: ArchiveFiles@2
      displayName: 'Archive Function App'
      inputs:
        rootFolderOrFile: '$(Build.ArtifactStagingDirectory)/function_package'
        includeRootFolder: false
        archiveType: zip
        archiveFile: $(Build.ArtifactStagingDirectory)/function-app.zip
        replaceExistingArchive: true

    - script: |
        echo "Verifying archive contents:"
        unzip -l $(Build.ArtifactStagingDirectory)/function-app.zip
        
        # Check if required files are present
        if unzip -l $(Build.ArtifactStagingDirectory)/function-app.zip | grep -q "function_app.py"; then
          echo "✓ function_app.py found"
        else
          echo "✗ function_app.py missing"
          exit 1
        fi
        
        if unzip -l $(Build.ArtifactStagingDirectory)/function-app.zip | grep -q "host.json"; then
          echo "✓ host.json found"
        else
          echo "✗ host.json missing"
          exit 1
        fi
        
        if unzip -l $(Build.ArtifactStagingDirectory)/function-app.zip | grep -q "requirements.txt"; then
          echo "✓ requirements.txt found"
        else
          echo "✗ requirements.txt missing"
          exit 1
        fi
        
        echo "Archive size:"
        ls -lh $(Build.ArtifactStagingDirectory)/function-app.zip
      displayName: 'Verify Archive'

    - publish: $(Build.ArtifactStagingDirectory)/function-app.zip
      artifact: function-package
      displayName: 'Publish Build Artifact'

- stage: DeployDev
  displayName: 'Deploy to Development'
  dependsOn: Build
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/develop'))
  jobs:
  - deployment: DeployToDev
    environment: 'development'
    strategy:
      runOnce:
        deploy:
          steps:
          - script: |
              echo "=== Development Deployment Information ==="
              echo "Environment: Development"
              echo "Function App: $(functionAppNameDev)"
              echo "Resource Group: $(resourceGroupDev)"
              echo "Build ID: $(Build.BuildId)"
              echo "Source Branch: $(Build.SourceBranch)"
              echo "Artifact: $(Pipeline.Workspace)/function-package/function-app.zip"
              echo "==========================================="
            displayName: 'Deployment Info'

          - task: AzureCLI@2
            displayName: 'Pre-Deploy Validation'
            inputs:
              azureSubscription: 'bestrong-arm'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "Validating Function App exists..."
                az functionapp show \
                  --name $(functionAppNameDev) \
                  --resource-group $(resourceGroupDev) \
                  --query "{name:name,state:state,kind:kind}" \
                  --output table
                
                echo "Checking Function App runtime..."
                RUNTIME=$(az functionapp config show \
                  --name $(functionAppNameDev) \
                  --resource-group $(resourceGroupDev) \
                  --query "linuxFxVersion" -o tsv)
                echo "Current runtime: $RUNTIME"
                
                if [[ "$RUNTIME" != *"Python"* ]]; then
                  echo "Setting Python runtime..."
                  az functionapp config set \
                    --name $(functionAppNameDev) \
                    --resource-group $(resourceGroupDev) \
                    --linux-fx-version "Python|3.9"
                fi
            
          - task: AzureFunctionApp@1
            displayName: 'Deploy Azure Function to Dev'
            inputs:
              azureSubscription: 'bestrong-arm'
              appType: 'functionAppLinux'
              appName: '$(functionAppNameDev)'
              package: '$(Pipeline.Workspace)/function-package/function-app.zip'
              deploymentMethod: 'auto'
              appSettings: '-FUNCTIONS_WORKER_RUNTIME python -FUNCTIONS_EXTENSION_VERSION ~4 -FileShareConnectionString "$(FileShareConnectionString)" -FormRecognizerEndpoint "$(FormRecognizerEndpoint)" -FormRecognizerKey "$(FormRecognizerKey)" -BlobStorageConnectionString "$(BlobStorageConnectionString)" -DiscordWebhookUrl "$(DiscordWebhookUrl)" -SlackWebhookUrl "$(SlackWebhookUrl)" -ENVIRONMENT development -BUILD_ID $(Build.BuildId)'

          - script: |
              echo "Testing dev endpoints with diagnostics..."
              BASE_URL="https://$(functionAppNameDev).azurewebsites.net/api"
              
              # Test ping endpoint first (simple connectivity)
              echo "=== Testing ping endpoint ==="
              PING_URL="$BASE_URL/ping"
              PING_RESPONSE=$(curl -s -w "\nHTTP_STATUS:%{http_code}" "$PING_URL" 2>&1)
              PING_STATUS=$(echo "$PING_RESPONSE" | grep "HTTP_STATUS:" | cut -d: -f2)
              echo "Ping Status: $PING_STATUS"
              
              if [ "$PING_STATUS" = "200" ]; then
                echo "✓ Basic connectivity confirmed!"
              else
                echo "⚠️ Basic connectivity failed, ping status: $PING_STATUS"
              fi
              
              # Test health endpoint with retry
              echo "=== Testing health endpoint ==="
              HEALTH_URL="$BASE_URL/health"
              
              for i in {1..8}; do
                echo "=== Dev health check attempt $i/8 ==="
                
                RESPONSE=$(curl -s -w "\nHTTP_STATUS:%{http_code}\nTOTAL_TIME:%{time_total}" "$HEALTH_URL" 2>&1)
                
                HTTP_STATUS=$(echo "$RESPONSE" | grep "HTTP_STATUS:" | cut -d: -f2)
                TOTAL_TIME=$(echo "$RESPONSE" | grep "TOTAL_TIME:" | cut -d: -f2)
                RESPONSE_BODY=$(echo "$RESPONSE" | sed '/HTTP_STATUS:/d' | sed '/TOTAL_TIME:/d')
                
                echo "HTTP Status: $HTTP_STATUS"
                echo "Response Time: ${TOTAL_TIME}s"
                echo "Response Body: $RESPONSE_BODY"
                
                if [ "$HTTP_STATUS" = "200" ]; then
                  echo "✓ Dev health check passed!"
                  break
                elif [ "$i" = "8" ]; then
                  echo "✗ Dev health check failed after 8 attempts"
                  echo "Continuing with dev deployment..."
                  break
                else
                  echo "Waiting 20 seconds before retry..."
                  sleep 20
                fi
              done
            displayName: 'Post-Deploy Health Check'

          - script: |
              echo "Sending dev deployment notification..."
              
              MESSAGE="🚀 **Dev Deployment Complete**\n✅ Build: $(Build.BuildId)\n🌿 Branch: $(Build.SourceBranch)\n🔧 Function App: $(functionAppNameDev)\n📊 Status: Success"
              
              curl -X POST -H 'Content-type: application/json' \
                --data "{\"content\":\"$MESSAGE\"}" \
                "$(DiscordWebhookUrl)" || echo "Failed to send Discord notification"
            displayName: 'Send Dev Deployment Notification'
            condition: always()

- stage: DeployProd
  displayName: 'Deploy to Production'
  dependsOn: Build
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  jobs:
  - deployment: DeployToProd
    environment: 'production'
    strategy:
      runOnce:
        deploy:
          steps:
          - script: |
              echo "=== Production Deployment Information ==="
              echo "Environment: Production"
              echo "Function App: $(functionAppNameProd)"
              echo "Resource Group: $(resourceGroupProd)"
              echo "Build ID: $(Build.BuildId)"
              echo "Source Branch: $(Build.SourceBranch)"
              echo "Artifact: $(Pipeline.Workspace)/function-package/function-app.zip"
              echo "=========================================="
            displayName: 'Production Deployment Info'

          - task: AzureCLI@2
            displayName: 'Pre-Deploy Production Validation'
            inputs:
              azureSubscription: 'bestrong-arm'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "Validating Production Function App..."
                az functionapp show \
                  --name $(functionAppNameProd) \
                  --resource-group $(resourceGroupProd) \
                  --query "{name:name,state:state,kind:kind,sku:appServicePlan}" \
                  --output table
                
                echo "Checking current runtime configuration..."
                RUNTIME=$(az functionapp config show \
                  --name $(functionAppNameProd) \
                  --resource-group $(resourceGroupProd) \
                  --query "linuxFxVersion" -o tsv)
                echo "Current runtime: $RUNTIME"
                
                # Ensure Python 3.9 runtime is set
                if [[ "$RUNTIME" != "Python|3.9" ]]; then
                  echo "Setting Python 3.9 runtime for production..."
                  az functionapp config set \
                    --name $(functionAppNameProd) \
                    --resource-group $(resourceGroupProd) \
                    --linux-fx-version "Python|3.9"
                  
                  echo "Waiting for runtime update to complete..."
                  sleep 60
                fi
                
                echo "Ensuring Function App is running..."
                APP_STATE=$(az functionapp show \
                  --name $(functionAppNameProd) \
                  --resource-group $(resourceGroupProd) \
                  --query "state" -o tsv)
                echo "App state: $APP_STATE"
                
                if [ "$APP_STATE" != "Running" ]; then
                  echo "Starting Function App..."
                  az functionapp start \
                    --name $(functionAppNameProd) \
                    --resource-group $(resourceGroupProd)
                  sleep 30
                fi
                
                # Check if we can access the SCM site
                echo "Testing SCM site accessibility..."
                SCM_URL="https://$(functionAppNameProd).scm.azurewebsites.net/api/ping"
                curl -s -f "$SCM_URL" && echo "SCM site accessible" || echo "SCM site not accessible"

          - task: AzureFunctionApp@1
            displayName: 'Deploy Azure Function to Production'
            inputs:
              azureSubscription: 'bestrong-arm'
              appType: 'functionAppLinux'
              appName: '$(functionAppNameProd)'
              package: '$(Pipeline.Workspace)/function-package/function-app.zip'
              deploymentMethod: 'zipDeploy'
              appSettings: |
                -FUNCTIONS_WORKER_RUNTIME python 
                -FUNCTIONS_EXTENSION_VERSION ~4 
                -WEBSITE_RUN_FROM_PACKAGE 1
                -FileShareConnectionString "$(FileShareConnectionString)" 
                -FormRecognizerEndpoint "$(FormRecognizerEndpoint)" 
                -FormRecognizerKey "$(FormRecognizerKey)" 
                -BlobStorageConnectionString "$(BlobStorageConnectionString)" 
                -DiscordWebhookUrl "$(DiscordWebhookUrl)" 
                -SlackWebhookUrl "$(SlackWebhookUrl)" 
                -ENVIRONMENT production 
                -BUILD_ID $(Build.BuildId)
                -WEBSITE_ENABLE_SYNC_UPDATE_SITE true

          - task: AzureCLI@2
            displayName: 'Post-Deploy Validation'
            inputs:
              azureSubscription: 'bestrong-arm'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "=== Post-Deploy Validation ==="
                
                # Wait for deployment to complete
                echo "Waiting for deployment to complete..."
                sleep 90
                
                # Check Function App status
                echo "Checking Function App status..."
                az functionapp show \
                  --name $(functionAppNameProd) \
                  --resource-group $(resourceGroupProd) \
                  --query "{name:name,state:state,availabilityState:availabilityState}" \
                  --output table
                
                # Check if functions are loaded
                echo "Checking function list..."
                az functionapp function list \
                  --name $(functionAppNameProd) \
                  --resource-group $(resourceGroupProd) \
                  --query "[].{name:name,triggerType:config.bindings[0].type}" \
                  --output table || echo "Could not retrieve function list"
                
                # Check application settings
                echo "Verifying critical application settings..."
                RUNTIME_SETTING=$(az functionapp config appsettings list \
                  --name $(functionAppNameProd) \
                  --resource-group $(resourceGroupProd) \
                  --query "[?name=='FUNCTIONS_WORKER_RUNTIME'].value" \
                  --output tsv)
                echo "FUNCTIONS_WORKER_RUNTIME: $RUNTIME_SETTING"
                
                VERSION_SETTING=$(az functionapp config appsettings list \
                  --name $(functionAppNameProd) \
                  --resource-group $(resourceGroupProd) \
                  --query "[?name=='FUNCTIONS_EXTENSION_VERSION'].value" \
                  --output tsv)
                echo "FUNCTIONS_EXTENSION_VERSION: $VERSION_SETTING"

          - script: |
              echo "Testing production endpoints with comprehensive diagnostics..."
              BASE_URL="https://$(functionAppNameProd).azurewebsites.net/api"
              
              # Function to test endpoint with retries
              test_endpoint() {
                local url=$1
                local name=$2
                local max_attempts=$3
                local expected_status=$4
                
                echo "=== Testing $name endpoint ==="
                
                for i in $(seq 1 $max_attempts); do
                  echo "Attempt $i/$max_attempts for $name..."
                  
                  RESPONSE=$(curl -s -w "\nHTTP_STATUS:%{http_code}\nTOTAL_TIME:%{time_total}" "$url" 2>&1)
                  
                  HTTP_STATUS=$(echo "$RESPONSE" | grep "HTTP_STATUS:" | cut -d: -f2)
                  TOTAL_TIME=$(echo "$RESPONSE" | grep "TOTAL_TIME:" | cut -d: -f2)
                  RESPONSE_BODY=$(echo "$RESPONSE" | sed '/HTTP_STATUS:/d' | sed '/TOTAL_TIME:/d')
                  
                  echo "HTTP Status: $HTTP_STATUS"
                  echo "Response Time: ${TOTAL_TIME}s"
                  echo "Response Body: $RESPONSE_BODY"
                  
                  if [ "$HTTP_STATUS" = "$expected_status" ]; then
                    echo "✅ $name endpoint test passed!"
                    return 0
                  elif [ "$i" = "$max_attempts" ]; then
                    echo "❌ $name endpoint test failed after $max_attempts attempts"
                    echo "Final response: $RESPONSE_BODY"
                    return 1
                  else
                    echo "Waiting 30 seconds before retry..."
                    sleep 30
                  fi
                done
              }
              
              # Test endpoints
              test_endpoint "${BASE_URL}/ping" "ping" 10 "200"
              test_endpoint "${BASE_URL}/health" "health" 10 "200"
              test_endpoint "${BASE_URL}/process-pdf" "process-pdf" 5 "400"  # Should return 400 without parameters
              
              echo "=== Endpoint testing completed ==="
            displayName: 'Comprehensive Endpoint Testing'

          - script: |
              echo "Running production smoke tests..."
              
              # Test the main process-pdf endpoint
              FUNCTION_URL="https://$(functionAppNameProd).azurewebsites.net/api/process-pdf"
              
              echo "Testing process-pdf endpoint (should return 400 without file_name)..."
              RESPONSE=$(curl -s -w "%{http_code}" "$FUNCTION_URL" 2>/dev/null)
              HTTP_STATUS="${RESPONSE: -3}"
              RESPONSE_BODY="${RESPONSE%???}"
              
              echo "Process-PDF endpoint status: $HTTP_STATUS"
              echo "Response: $RESPONSE_BODY"
              
              if [ "$HTTP_STATUS" = "400" ] || [ "$HTTP_STATUS" = "401" ]; then
                echo "✅ Process-PDF endpoint is responding correctly"
              else
                echo "⚠️ Process-PDF endpoint returned unexpected status: $HTTP_STATUS"
              fi
              
              # Test legacy endpoint
              LEGACY_URL="https://$(functionAppNameProd).azurewebsites.net/api/PdfOcrFunction?name=test"
              echo "Testing legacy endpoint..."
              LEGACY_RESPONSE=$(curl -s "$LEGACY_URL" 2>/dev/null || echo "Failed to connect")
              echo "Legacy endpoint response: $LEGACY_RESPONSE"
              
            displayName: 'Production Smoke Tests'

          - script: |
              echo "Sending production deployment notifications..."
              
              # Discord notification
              MESSAGE="🎉 **Production Deployment Complete**\n✅ Build: $(Build.BuildId)\n🌟 Branch: $(Build.SourceBranch)\n🚀 Function App: $(functionAppNameProd)\n📊 Status: Success\n🟢 Ready for use!"
              
              curl -X POST -H 'Content-type: application/json' \
                --data "{\"content\":\"$MESSAGE\"}" \
                "$(DiscordWebhookUrl)" || echo "Failed to send Discord notification"
              
              # Slack notification  
              curl -X POST -H 'Content-type: application/json' \
                --data "{\"text\":\"🎉 *Production Deployment Complete*\n✅ Build: $(Build.BuildId)\n🌟 Branch: $(Build.SourceBranch)\n🚀 Function App: $(functionAppNameProd)\n📊 Status: Success\n🟢 Ready for use!\"}" \
                "$(SlackWebhookUrl)" || echo "Failed to send Slack notification"
            displayName: 'Send Production Deployment Notifications'
            condition: always()

- stage: PostDeploymentTests
  displayName: 'Post-Deployment Integration Tests'
  dependsOn: 
    - DeployDev
    - DeployProd
  condition: always()
  jobs:
  - job: IntegrationTests
    displayName: 'Run Integration Tests'
    condition: or(succeeded('DeployDev'), succeeded('DeployProd'))
    steps:
    - script: |
        echo "Running post-deployment integration tests..."
        
        # Determine which environment to test
        if [ "$(Build.SourceBranch)" = "refs/heads/main" ]; then
          FUNCTION_APP_NAME="$(functionAppNameProd)"
          ENVIRONMENT="production"
        else
          FUNCTION_APP_NAME="$(functionAppNameDev)"
          ENVIRONMENT="development"
        fi
        
        echo "Testing environment: $ENVIRONMENT"
        echo "Function App: $FUNCTION_APP_NAME"
        
        BASE_URL="https://${FUNCTION_APP_NAME}.azurewebsites.net/api"
        
        # Test health endpoint
        echo "Testing health endpoint..."
        HEALTH_RESPONSE=$(curl -s "${BASE_URL}/health" 2>/dev/null || echo "Failed")
        echo "Health response: $HEALTH_RESPONSE"
        
        # Test legacy endpoint
        echo "Testing legacy endpoint..."
        LEGACY_RESPONSE=$(curl -s "${BASE_URL}/PdfOcrFunction?name=IntegrationTest" 2>/dev/null || echo "Failed")
        echo "Legacy response: $LEGACY_RESPONSE"
        
        # Test process-pdf endpoint (should return 400 without parameters)
        echo "Testing process-pdf endpoint parameter validation..."
        PDF_RESPONSE=$(curl -s -w "%{http_code}" "${BASE_URL}/process-pdf" 2>/dev/null)
        PDF_STATUS="${PDF_RESPONSE: -3}"
        echo "Process-PDF response code: $PDF_STATUS"
        
        if [ "$PDF_STATUS" = "400" ]; then
          echo "✅ Process-PDF endpoint correctly validates parameters"
        else
          echo "⚠️ Process-PDF endpoint returned unexpected status: $PDF_STATUS"
        fi
        
        echo "Integration tests completed for $ENVIRONMENT environment"
        
        # Send test results notification
        if [ "$PDF_STATUS" = "400" ] && [[ "$HEALTH_RESPONSE" == *"healthy"* ]]; then
          TEST_STATUS="✅ Passed"
        else
          TEST_STATUS="⚠️ Partially Passed"
        fi
        
        curl -X POST -H 'Content-type: application/json' \
          --data "{\"content\":\"🧪 **Integration Tests Complete**\n🎯 Environment: $ENVIRONMENT\n📊 Status: $TEST_STATUS\n🔗 App: $FUNCTION_APP_NAME\"}" \
          "$(DiscordWebhookUrl)" || echo "Failed to send test notification"
      displayName: 'Integration Tests'

  - job: NotifyCompletion
    displayName: 'Pipeline Completion Notification'
    dependsOn: IntegrationTests
    condition: always()
    steps:
    - script: |
        # Determine overall pipeline status
        PIPELINE_STATUS="Unknown"
        if [ "$(Agent.JobStatus)" = "Succeeded" ]; then
          PIPELINE_STATUS="✅ Success"
          STATUS_ICON="🎉"
        else
          PIPELINE_STATUS="❌ Failed"
          STATUS_ICON="⚠️"
        fi
        
        ENVIRONMENT="Unknown"
        if [ "$(Build.SourceBranch)" = "refs/heads/main" ]; then
          ENVIRONMENT="🚀 Production"
        elif [ "$(Build.SourceBranch)" = "refs/heads/develop" ]; then
          ENVIRONMENT="🔧 Development"
        fi
        
        MESSAGE="$STATUS_ICON **Pipeline Complete**\n📋 Build: $(Build.BuildId)\n🌿 Branch: $(Build.SourceBranch)\n🎯 Environment: $ENVIRONMENT\n📊 Status: $PIPELINE_STATUS"
        
        # Send final notifications
        curl -X POST -H 'Content-type: application/json' \
          --data "{\"content\":\"$MESSAGE\"}" \
          "$(DiscordWebhookUrl)" || echo "Failed to send final Discord notification"
          
        curl -X POST -H 'Content-type: application/json' \
          --data "{\"text\":\"$MESSAGE\"}" \
          "$(SlackWebhookUrl)" || echo "Failed to send final Slack notification"
      displayName: 'Send Pipeline Completion Notification'